#!/usr/bin/env node

var fs = require("fs"),
    path = require("path"),
    readline = require("readline"),
    commander = require("commander"),
    topojson = require("../dist/topojson-server");

commander
    .version(require("../package.json").version)
    .usage("[options] <name:file>…")
    .option("-o, --out <file>", "output file name; defaults to “-” for stdout", "-")
    .option("-n, --newline-delimited", "accept newline-delimited JSON")
    .option("-q, --quantization <count>", "pre-quantization parameter; 0 disables quantization", 0)
    .parse(process.argv);

if (commander.args.length < 1) commander.args[0] = "-";

var objects = {}, out = commander.out === "-" ? process.stdout : fs.createWriteStream(commander.out);

out.on("error", function(error) {
  if (error.code === "EPIPE" || error.errno === "EPIPE") {
    process.exit(0);
  }
});

Promise.all(commander.args.map(read)).then(write);

function read(specifier) {
  var i = specifier.indexOf("="),
      file = i >= 0 ? specifier.slice(i + 1) : specifier,
      name = i >= 0 ? specifier.slice(0, i) : path.basename(specifier, path.extname(specifier));
  if (name in objects) {
    console.error("error: object “" + name + "” is not unique");
    process.exit(1);
  }
  objects[name] = undefined;
  return (commander.newlineDelimited ? readNewlineDelimitedObject : readObject)(file === "-"
      ? process.stdin : fs.createReadStream(file))
      .then(function(object) { objects[name] = object; });
}

function readNewlineDelimitedObject(stream) {
  return new Promise(function(resolve, reject) {
    var objects = [];
    readline.createInterface({
      input: stream,
      output: null
    }).on("line", function(line) {
      objects.push(JSON.parse(line));
    }).on("close", function() {
      resolve(objects.length === 0 || objects[0].type === "Feature"
          ? {type: "FeatureCollection", features: objects}
          : {type: "GeometryCollection", geometries: objects});
    }).on("error", reject);
  });
}

function readObject(stream) {
  return new Promise(function(resolve, reject) {
    var chunks = [];
    stream
        .on("data", function(chunk) { chunks.push(chunk); })
        .on("end", function() { resolve(JSON.parse(chunks.join(""))); })
        .on("error", reject);
  });
}

function write() {
  out.write(JSON.stringify(topojson.topology(objects, +commander.quantization)));
  out[out === process.stdout ? "write" : "end"]("\n");
}
